from openid import cryptutil

class OpenIDStore(object):
    """
    This is the interface for the store objects the OpenID consumer
    library uses.  It is a single class that provides all of the
    persistence mechanisms that the OpenID consumer library needs.


    @cvar AUTH_KEY_LEN: The length of the auth key that should be
        returned by the C{L{getAuthKey}} method.
    """

    AUTH_KEY_LEN = 20

    def storeAssociation(self, association):
        """
        This method puts a C{L{ConsumerAssociation}} object into
        storage.


        @param association: The C{L{ConsumerAssociation}} to store.

        @type association: C{L{ConsumerAssociation}}
        """
        raise NotImplementedError
    

    def getAssociation(self, server_url):
        """
        This method returns a C{L{ConsumerAssociation}} object from storage
        that matches the server_url.  It returns C{None} if no such
        association is found or if the matching association is
        expired.

        This method is allowed (and encouraged) to garbage collect
        expired associations when found.


        @param server_url: The URL of the identity server to get the
            association for.

        @type server_url: C{str}


        @return: The C{L{ConsumerAssociation}} for the given identity
            server.

        @rtype: C{L{ConsumerAssociation}} or C{None}
        """
        raise NotImplementedError

    def removeAssociation(self, server_url, handle):
        """
        This method removes the matching association if it's found,
        and returns whether the association was removed or not.


        @param server_url: The URL of the identity server the
            association to remove belongs to.

        @type server_url: C{str}


        @param handle: This is the handle of the association to
            remove.  If there isn't an association found that matches
            both the given URL and handle, then there was no matching
            handle found.

        @type handle: C{str}


        @return: Returns whether or not the given association existed.

        @rtype: C{bool}
        """
        raise NotImplementedError


    def storeNonce(self, nonce):
        """
        Stores a nonce.  This is used to prevent replay attacks.


        @param nonce: The nonce to store.

        @type nonce: C{str}
        """
        raise NotImplementedError

    def useNonce(self, nonce):
        """
        This method is called when the library is attempting to use a
        nonce.  If the nonce is in the store, this method removes it
        and returns True.  Otherwise it returns False.

        This method is allowed and encouraged to treat nonces older
        than some period (like 6 hours) as no longer existing, and
        return False and remove them.


        @param nonce: The nonce to use.

        @type nonce: C{str}


        @return: C{True} if the nonce existed, C{False} if it didn't.

        @rtype: C{bool}
        """
        raise NotImplementedError

    def getAuthKey(self):
        """
        This method returns a key used to sign the tokens, to
        ensure that they haven't been tampered with in transit.  It
        should return the same key every time it is called.  The key
        returned should be C{L{AUTH_KEY_LEN}} bytes long.

        @return: The key.  It should be C{L{AUTH_KEY_LEN}} bytes in
            length, and use the full range of byte values.  That is,
            it should be treated as a lump of binary data stored in a
            C{str}.

        @rtype: C{str}
        """
        raise NotImplementedError

    def isDumb(self):
        """
        This method must return C{True} if the store is a
        dumb-mode-style store.  Unlike all other methods in this
        class, this one provides a default implementation, which
        returns C{False}.

        In general, any custom subclass of C{L{OpenIDStore}} won't
        override this method, as custom subclasses are only likely to
        be created when the store is fully functional.

        @return: C{True} if the store works fully, C{False} if the
           consumer will have to use dumb mode to use this store.

        @rtype: C{bool}
        """
        return False

class DumbStore(OpenIDStore):
    """
    This is a store for use in the worst case, when you have no way of
    saving state on the consumer server.  Using this store makes the
    consumer vulnerable to replay attacks (though only within the
    lifespan of the tokens), as it's unable to use nonces.  Avoid
    using this store if it is at all possible.
    """
    def __init__(self, secret_phrase):
        """
        Creates a new DumbStore instance.  For the security of the
        tokens generated by the library, this class attempts to at
        least have a secure implementation of C{L{getAuthKey}}.

        When you create an instance of this class, pass in a secret
        phrase.  The phrase is hashed with sha1 to make it the correct
        length and form for an auth key.  That allows you to use a
        long string as the secret phrase, which means you can make it
        very difficult to guess.

        Each C{L{DumbStore}} instance that is created for use by your
        consumer site needs to use the same C{secret_phrase}.

        @param secret_phrase: The phrase used to create the auth key
            returned by C{L{getAuthKey}}

        @type secret_phrase: C{str}
        """
        self.auth_key = cryptutil.sha1(secret_phrase)

    def storeAssociation(self, unused_association):
        """
        This implementation does nothing.
        """
        pass

    def getAssociation(self, unused_server_url):
        """
        This implementation always returns C{None}.


        @return: C{None}

        @rtype: C{None}
        """
        return None

    def removeAssociation(self, unused_server_url, unused_handle):
        """
        This implementation always returns C{False}.


        @return: C{False}

        @rtype: C{bool}
        """
        return False

    def storeNonce(self, nonce):
        """
        This implementation does nothing.
        """
        pass

    def useNonce(self, nonce):
        """
        In a system truly limited to dumb mode, nonces must all be
        accepted.  This therefore always returns C{True}, which makes
        replay attacks feasible during the lifespan of the token.


        @return: C{True}

        @rtype: C{bool}
        """
        return True

    def getAuthKey(self):
        """
        This method returns the auth key generated by the constructor.


        @return: The auth key generated by the constructor.

        @rtype: C{str}
        """
        return self.auth_key

    def isDumb(self):
        """
        This store is a dumb mode store, so this method is overridden
        to return C{True}.


        @return: C{True}

        @rtype: C{bool}
        """
        return True
