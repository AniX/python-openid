from binascii import hexlify
from openid import oidUtil
from openid.consumer.stores import OpenIDStore
from openid.consumer.filestore import serializeAssociation, deserializeAssociation

NONCE_CODE = 'N'
ASSOCATION_CODE = 'A'

class MemCacheOpenIDStore(OpenIDStore):
    """
    This class implements a memcached-based OpenID consumer
    store. MemCached is the cache implementation used by
    LiveJournal.com. It is expected that if you are using this store
    implementation, you are already using or are transitioning to
    using memcached for your application.

    There are a few things to note about this store implementation and
    how it interacts with OpenID. This store uses only memcached as a
    backend. That means that if the memcached process restarts or is
    flushed, then the data is lost. The data that is stored in this
    store is generally ephemeral, so the impact is relatively low. In
    the worst case, many currently in-progress authentications will
    fail where they may have succeeded if they could have
    completed. This means that if your memcached processes are
    relatively stable and/or you do not generally handle a high rate
    of logins, the user-visible consequences of this data loss will be
    minimal.

    Most of the methods of this class should be considered
    implementation details.  People wishing to just use this class
    need only pay attention to the C{L{__init__}} method.

    Resources
    =========

    For more information about memcached, see:
    U{http://danga.com/memcached/}

    The protocol can be found at:
    U{http://cvs.danga.com/browse.cgi/wcmtools/memcached/doc/protocol.txt?rev=HEAD}

    The Python memcached client that this implementation requires can be
    found at:
    U{ftp://ftp.tummy.com/pub/python-memcached/}


    @sort: __init__
    """
    def __init__(self, memcache, key_prefix='', secret_phrase=None):
        """Initialize the memcached store.

        @param memcache: a handle to a memcached client

        @type memcache: C{memcache.Client}


        @param key_prefix: prefix to prepend to all generated keys to
            keep them unique

        @type key_prefix: C{str}


        @param secret_phrase: Optional secret for use when you want to
            make sure that you are always using the same secret to
            sign authentication tokens. If you have many memcache
            servers, this will ensure that only the users whose OpenID
            transaction information is stored in a particular cache
            will be affected when that cache is flushed. Choose this
            value carefully. A truly random number is best if you do
            not let the library choose.

        @type secret_phrase: C{str}
        """
        self.memcache = memcache
        self.setKeyPrefix(key_prefix)
        if secret_phrase is None:
            self.auth_key = None
        else:
            self.auth_key = oidUtil.sha1(secret_phrase)
        self.nonce_timeout = 6 * 60 * 60

    def _nonceKey(self, nonce):
        """Generate a memcached key for this nonce

        @param nonce: the nonce string
        @type nonce: str

        @return: the memcached key for the nonce
        @rtype: str
        """
        return self.key_prefix + NONCE_CODE + nonce

    def _assocKey(self, server_url):
        """Generate a memcached key for storing an association for
        this URL.

        @param server_url: the server url
        @type server_url: str

        @return: the memcached key for the server url
        @rtype: str
        """
        hashed_url = hexlify(oidUtil.sha1(server_url))
        return self.key_prefix + ASSOCATION_CODE + hashed_url

    def setKeyPrefix(self, prefix):
        """Add a prefix to all keys that are generated by this code in
        order to make sure that they do not conflict with the keys
        that are generated by other parts of the application. By
        default, there is no prefix added.

        From http://cvs.danga.com/browse.cgi/wcmtools/memcached/doc/protocol.txt?rev=HEAD

        Currently the length limit of a key is set at 250 characters
        (of course, normally clients wouldn't need to use such long
        keys); the key must not include control characters or
        whitespace.

        This implementation will add up to 21 bytes to the end of the
        prefix that you supply.

        @type prefix: str

        @return: None
        @rtype: NoneType
        """
        self.key_prefix = prefix
        self.auth_key_key = prefix + 'K'

    def getAuthKey(self):
        """Return the secret key used for signing authentication tokens.

        Will create a new key if the key does not yet exist. If the
        cache where this token is stored is flushed, then all
        in-process authentications will break. Use the secret_phrase
        argument to the constructor to protect yourself against this.

        @return: the secret auth key
        @rtype: str
        """
        if self.auth_key is not None:
            return self.auth_key

        for _ in xrange(3):
            auth_key = self.memcache.get(self.auth_key_key)
            if auth_key is not None:
                return auth_key

            # On failure to get, attempt to set a new key.
            new_key = oidUtil.randomString(self.AUTH_KEY_LEN)
            was_set = self.memcache.set(self.auth_key_key, new_key)
            if was_set:
                return new_key

            # If we failed, assume that it was because someone else
            # set it before us (race condition), so loop back to the
            # get.

        raise RuntimeError('memcache looped!')

    def storeNonce(self, nonce):
        """Mark a nonce as present in the cache. The nonce is used to
        prevent replay attacks.

        @param nonce: the nonce value
        @type nonce: str

        @return: None
        """
        key = self._nonceKey(nonce)
        self.memcache.set(key, '', self.nonce_timeout)

    def useNonce(self, nonce):
        """
        check whether this nonce has already been used, and also
        mark it as used if it has not.
        
        Ideally the implementation of this function would be

        C{key = self._nonceKey(nonce)
        return self.memcache.delete(key)}

        but the Python memcached library returns success even when
        the return response is not what it is expecting. This
        introduces a race-condition, since more than one get() can
        return successfully before the delete() happens. In the long
        run, we hope that the Python memcached library will return
        whether the delete succeeded. In the short run, the window
        for exploitation is very short. It opens the client to
        replay attacks within the time between the get() and the
        delete(). If you are paranoid, do not use this store.

        @param nonce: the nonce value
        @type nonce: str

        @return: whether this nonce is present in the cache
        @rtype: bool
        """
        key = self._nonceKey(nonce)
        val = self.memcache.get(key)
        if val is None:
            return False
        else:
            self.memcache.delete(key)
            return True

    def getAssociation(self, server_url):
        """Get the association for the given server URL.

        @param server_url: the server's url
        @type server_url: str

        @return: the association for this server or None
        @rtype: openid.consumer.interface.ConsumerAssociation or NoneType
        """
        key = self._assocKey(server_url)
        assoc_s = self.memcache.get(key)
        if assoc_s is None:
            return None

        try:
            assoc = deserializeAssociation(assoc_s)
        except ValueError:
            self.memcache.delete(key)
            return None

        # Clean up expired associations
        if not assoc or assoc.getExpiresIn() == 0:
            self.memcache.delete(key)
            return None
        else:
            return assoc

    def storeAssociation(self, assoc):
        assoc_s = serializeAssociation(assoc)
        key = self._assocKey(assoc.server_url)
        ret = self.memcache.set(key, assoc_s, assoc.issued + assoc.lifetime)
        if not ret:
            raise RuntimeError('Error setting memcache key %r' % key)

    def removeAssociation(self, server_url, handle):
        key = self._assocKey(server_url)
        assoc_s = self.memcache.get(key)
        if assoc_s is None:
            return False

        try:
            assoc = deserializeAssociation(assoc_s)
        except ValueError:
            self.memcache.delete(key)
            return False

        if assoc.handle == handle:
            if not self.memcache.delete(key):
                raise RuntimeError('MemCached error deleting association %r' %
                                   (server_url, handle))
            return True

        return False
