"""Extension argument processing code
"""
import warnings

__all__ = ['Message', 'NamespaceMap', 'SREG_URI']

# URI for Simple Registration extension, the only commonly deployed
# OpenID 1.x extension, and so a special case
SREG_URI = 'http://openid.net/sreg/1.0'

# XXX: testme!
def fixNamespaceURI(ns_uri, stacklevel=2):
    """Check for deprecated API usage and fix the namespace URI if
    it's 'sreg'

    @param ns_uri: The string to check as a namespace URI

    @param stacklevel: the stack level for any warnings that are
        generated by this function. 1 is the call point, 2 is the
        caller of that function, etc.

    @returns: The namespace URI, possibly cleaned up
    """
    if ns_uri is not None and ':' not in ns_uri:
        fmt = 'OpenID 2.0 namespace identifiers SHOULD be URIs. Got %r'
        warnings.warn(fmt % (ns_uri,), DeprecationWarning,
                      stacklevel=(stacklevel + 1))

        if ns_uri == 'sreg':
            fmt = 'Using %r instead of "sreg" as namespace'
            warnings.warn(fmt % (SREG_URI,), DeprecationWarning,
                          stacklevel=(stacklevel + 1))
            return SREG_URI

    return ns_uri

# XXX: TESTME!
class Message(object):
    """
    In the implementation of this object, None represents the global
    namespace as well as a namespace with no key.

    @cvar namespace_alaises: A dictionary specifying specific
        namespace-URI to alias mappings that should be used when
        generating namespace aliases.

    @ivar ns_args: two-level dictionary of the values in this message,
        grouped by namespace URI. The first level is the namespace
        URI.

    @ivar signed: list of fields to sign. It contains pairs of
        namespace and key. The namespace alias declarations are
        automatically signed.
    """

    def __init__(self):
        """Create an empty Message"""
        self.ns_args = {}
        self.args = {}
        self.signed = []
        self.namespaces = NamespaceMap()

    def toArgs(self):
        """Build a dictionary out of the arguments defined for this
        message (realize the namespace mappings)

        @returntype: {unicode:unicode}
        """
        args = dict(self.args)

        signed_s = []
        for ns_uri, key in self.signed:
            if ns_uri is None:
                signed_s.append(key)
            else:
                alias = self.namespaces.getAlias(ns_uri)
                assert alias is not None
                if key is None:
                    signed_s.append(alias)
                else:
                    signed_s.append('%s.%s' % (alias, key))

        for ns_uri, alias in self.namespaces.iteritems():
            ns_key = 'ns.' + alias
            args[ns_key] = ns_uri
            signed_s.append(ns_key)

        if signed_s:
            args['signed'] = ','.join(signed_s)

        for ns_uri, values in self.ns_args.iteritems():
            alias = self.namespaces.getAlias(ns_uri)
            for k, v in values.iteritems():
                if k is None:
                    args[alias] = v
                else:
                    args['%s.%s' % (alias, k)] = v


        return args

    def toQueryArgs(self):
        return dict([('openid.' + k, v)
                     for k, v in self.toArgs().iteritems()])

    def addNSArg(self, namespace_uri, key, value, signed=True):
        """Add a single argument to this namespace"""
        if namespace_uri is None:
            ns_args = self.args
        else:
            namespace_uri = fixNamespaceURI(namespace_uri)
            try:
                ns_args = self.ns_args[namespace_uri]
            except KeyError:
                ns_args = self.ns_args[namespace_uri] = {}

            self.namespaces.add(namespace_uri)

        if signed:
            k = (namespace_uri, key)
            if k not in self.signed:
                self.signed.append(k)

        ns_args[key] = value

    def addArg(self, key, value, signed=True):
        self.addNSArg(None, key, value, signed)

    def addNSArgs(self, namespace_uri, values, signed=True):
        """Add a set of values to this namespace. Takes the same
        type as a second parameter as dict.update."""
        for k, v in values.iteritems():
            self.addNSArg(namespace_uri, k, v, signed)

    def addArgs(self, values, signed=True):
        self.addNSArgs(None, values, signed)

    def getNS(self, ns_uri, key, default=None):
        if ns_uri is None:
            args = self.args
        else:
            try:
                args = self.ns_args[ns_uri]
            except KeyError:
                return default

        return args.get(key, default)

    def get(self, key, default=None):
        return self.args.get(key, default)

    def getNamespaceArgs(self, namespace_uri):
        """Get the arguments that are defined for this namespace URI

        @returns: mapping from namespaced keys to values
        @returntype: dict
        """
        if namespace_uri is None:
            return dict(self.args)
        else:
            return dict(self.ns_args.get(namespace_uri, {}))

#XXX: testme!
class NamespaceMap(object):
    # namespaces that should use a certain alias (for
    # backwards-compatibility or beauty)
    default_aliases = {SREG_URI:'sreg'}

    def __init__(self):
        self.alias_to_namespace = {}
        self.namespace_to_alias = {}

    def getAlias(self, namespace_uri):
        return self.namespace_to_alias.get(namespace_uri)

    def getNamespaceURI(self, alias):
        return self.alias_to_namespace.get(alias)

    def iterNamespaceURIs(self):
        return iter(self.namespace_to_alias)

    def iterAliases(self):
        return iter(self.alias_to_namespace)

    def iteritems(self):
        """Iterate over the mapping

        @returns: iterator of (namespace_uri, alias)
        """
        return self.namespace_to_alias.iteritems()

    def addAlias(self, namespace_uri, desired_alias):
        """Add an alias from this namespace URI to the desired alias
        """
        namespace_uri = fixNamespaceURI(namespace_uri, stacklevel=3)
        self._addAlias(namespace_uri, desired_alias)

    def _addAlias(self, namespace_uri, desired_alias):
        # Check that there is not a namespace already defined for
        # the desired alias
        current_namespace_uri = self.alias_to_namespace.get(desired_alias)
        if (current_namespace_uri is not None
            and current_namespace_uri != namespace_uri):

            fmt = (
                'Cannot map %r to alias %r. '
                '%r is already mapped to alias %r') % (
                namespace_uri,
                desired_alias,
                current_namespace_uri,
                desired_alias)
            raise KeyError(msg)

        # Check that there is not already a (different) alias for
        # this namespace URI
        alias = self.namespace_to_alias.get(namespace_uri)
        if alias is not None and alias != desired_alias:
            fmt = ('Cannot map %r to alias %r. '
                   'It is already mapped to alias %r')
            raise KeyError(fmt % (namespace_uri, desired_alias, alias))

        self.alias_to_namespace[desired_alias] = namespace_uri
        self.namespace_to_alias[namespace_uri] = desired_alias
        return desired_alias

    def add(self, namespace_uri):
        """Add this namespace URI to the mapping, without caring what
        alias it ends up with"""
        namespace_uri = fixNamespaceURI(namespace_uri, stacklevel=3)

        # See if this namespace is already mapped to an alias
        alias = self.namespace_to_alias.get(namespace_uri)
        if alias is not None:
            return alias

        # See if there is a default alias for this namespace
        default_alias = self.default_aliases.get(namespace_uri)
        if default_alias is not None:
            try:
                self._addAlias(namespace_uri, desired_alias)
            except KeyError:
                pass
            else:
                return default_alias

        # Fall back to generating a numerical alias
        i = 0
        while True:
            alias = str(i)
            try:
                self._addAlias(namespace_uri, str(i))
            except KeyError:
                i += 1
            else:
                return alias

    def isDefined(self, namespace_uri):
        return namespace_uri in self.namespace_to_alias

    def __contains__(self, namespace_uri):
        return self.isDefined(namespace_uri)
